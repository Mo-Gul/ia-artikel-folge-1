include::config.adoc[]

== Docs-As-Code - Die Grundlagen

=== Schlechte Dokumentation  kostet Geld

Eine grossangelegte Umfragefootnote:[https://opensourcesurvey.org/2017/]
zu "Open Source" zeigt, dass unvollständige oder verwirrende Dokumentation
zu den Hauptproblem freier Software zählt. Das gilt neben Anwendungungsdokumentation
insbesondere auch für technische Dokumentation, etwa von Softwarearchitektur.

Diese Aussage können wir sicherlich
verallgemeinern -  schlechte Dokumentation von Software erschwert
Änderung, Support und letztlich auch Nutzung.

Wir möchten hier auf _technische Dokumentation_ von Software abzielen, also
beispielsweise Entwicklungs-, Architektur- und Betriebsdokumentation. Das Thema
_Anwendungsdokumentation_ klammern wir bewusst aus.

Unserer Erfahrung nach behindern eine ganze Reihe von Faktoren
die Erstellung und kontinuierliche Pflege technischer Dokumentation:

1. Ungeeignete Werkzeuge, die ursprünglich nicht für Erstellung und Pflege
solcher Dokumentation gedacht waren.
2. Geringe Motivation seitens Entwicklungsteams, oftmals verstärkt durch die
oben genannten Defizite der entsprechenden Werkzeuge.
3. Unklare Vorstellung über Struktur, Form und Inhalt von Dokumentation:
Entwicklungsteams haben keine klare Vorstellung davon, was und wie sie
dokumentieren sollen.
4. Schlechte Vorlagen ("Templates") für Dokumentation.

=== Technische Dokumentation als "Leichtgewicht"
Stellen Sie sich vor, Sie erstellen und pflegen Ihre technische Dokumentation
genau so wie auch Ihren Quellcode: Im selben Texteditor oder einer IDE,
als reiner Text, versioniert in Ihrem Lieblings-Repository (wir mögen Git).
Dann verschwindet für Entwicklungsteams das erste der oben genannten Probleme (nämlich
  die ungeeigneten Werkzeuge), und die Motivation zur Erstellung und Pflege von Doku
  wird auch gleich besser.

Wir zeigen Ihnen genau diesen Ansatz: Integrieren Sie das bisher ungeliebten
Thema _Dokumentation_ mit Hilfe robuster Open-Source Werkzeuge einfach und effektiv
in Ihre Softwareentwicklung, mit Hilfe Ihres favorisierten Texteditors.
_Mergen_ und _branchen_ Sie Dokumentation genau wie Quellcode. Statt binäre Dokumente
per Email zu versenden und Versionsnummern und Namenskürzel an die Dateinamen zu hängen,
checken Sie Ihre Dokumentation per commit und push ein, mit derselben Branching-Strategie
mit der Sie auch Ihre Software entwickeln.

Damit können Sie ein breites Spektrum technischer Dokumentation von Software abdecken,
beispielsweise Entwicklungs-, Architektur- oder auch Betriebsdokumentation.  Wir persönlich
haben auch Anforderungs- und Userdokumentation auf diese Weise erstellt.

Für diesen Ansatz hat sich im Netz der Begriff
https://www.writethedocs.org/guide/docs-as-code/[_Docs-as-Code_] etabliert -
Dokumentation genauso wie Quellcode behandeln.

Mit Docs-as-Code reduzieren Sie die lästigen Hemmschwellen, die durch Werkzeugwechsel
und/oder Medienbrüche aufgetreten sind. Sie können Dokumente beliebig aufteilen
(sprich: im Team arbeitsteilig angehen), und Dokumentation
in den Build- und Testprozess ihrer Software integrieren.

Sollten Sie in Ihrem Team bereits mit https://arc42.org[arc42] arbeiten,
so werden Sie sich mit dem Docs-As-Code Ansatz besonders wohl fühlen.

Andere Beteiligte (_Stakeholder_) dürfen ihre favorisierten Tools wie Word,
Powerpoint, Excel oder auch Enterprise-Architect(TM) weiter verwenden,
denn Docs-as-Code kann automatisiert eine Vielzahl anderer Dokumenttypen integrieren
(darauf gehen wir im zweiten Teil dieses Artikels detalliert ein).

Falls das für Sie attraktiv klingt - herzlich willkommen. Wir haben diese Ansätze
bereits mehrfach in der Praxis erfolgreich einsetzen dürfen - und einige unserer
Erfahrungen in diesem und den folgenden Artikeln verarbeitet.

Sie finden _Docs-as-Code_ in drei Teilen erläutert:

1. Die Grundlagen: In der vorliegenden Folge zeigen wir Ihnen AsciiDoc als
unsere favorisierte Grundlage für technische Dokumentation. Sie erfahren allerhand
über Gliederung, Formatierung, Modularisierung, Integration von Diagrammen
und Quellcode.
2. In der zweiten Folge lernen Sie
https://doctoolchain.github.io/docToolchain/[docToolchain] kennen, die
OpenSource Lösung zur Unterstützung des Docs-As-Code Ansatzes.
 Sie lernen die Integration von Office-Dokumenten, Confluence(tm) und Enterprise-Architect(TM)  in ihre Dokumentation kennen.
3. In der dritten Folge bringen wir _alles unter einem Dach_ unter:
Sie erfahren, wie Sie die verschiedenen Arten von Dokumentation (etwa Architektur- und Entwicklungsdokumentation sowie User-Manuals, Tutorials
 etc) im Rahmen einer integrativen Website zusammenführen können.

Sämtlichen Quellcode und Beispiele aller drei Teile finden Sie online
in einem öffentlichen (git-) Repository.

Um Ihnen das manchmal ungeliebte Thema _Dokumentation_ etwas schmackhaft zu machen, möchten wir Ihnen einen
Ausblick auf das mögliche Endergebnis geben: Eine Website
(siehe <<hsc-homepage>>), auf der Sie drei verschiedene Typen von Dokumentation unter einem (homogenen) Dach vereinigt finden:

== So sieht's aus
In <<hsc-homepage>> sehen Sie eine (generierte) Website, auf der wir die gesamte
Dokumentation für ein Softwaresystem zusammengeführt haben.

[[hsc-homepage]]
.Eine Doku-Website
image::hsc-aim42-site-screenshot.png[]

// Anmerkung (GS): Einen live-screenshot in einen Artikel/Buch,
// ohne dass ein Mensch den kontrolliert,
// ergibt in meinen Augen überhaupt keinen Sinn... Nur Risiko und Techno-Spielerei...


In der Navigationsleiste der Abbildung 1 finden Sie drei typische Arten von
Dokumentation, nämlich "User-Guide" (Benutzungsanleitung o.ä.), "Development Guide"
(detaillierte Informationen für das Entwicklungsteam) sowie die Architekturdokumentation,
beispielsweise auf Basis des https://arc42.org[arc42 Templates].

Probieren Sie das Original unter https://hsc.aim42.org ruhig aus. Die gesamte
Site wird nach dem Motto
https://en.wikipedia.org/wiki/Eating_your_own_dog_food[_drink your own champagne_]
generiert, sämtliche Quellen liegen unter Versionsverwaltung und
sind im https://github.com/aim42/htmlSanityCheck[Github-Repository] öffentlich.


== Bestandteile technischer Dokumentation

Für technische Dokumentation benötigen Sie _die üblichen Verdächtigen_,
nämlich Überschriften, Fliesstext mit Auszeichnungen wie fett und kursiv
sowie Tabellen, Diagramme und Querverweise. Uns helfen oft Codebeispiele
(am besten inkludiert aus dem Original-Code-Repository), und am besten
soll unsere Dokumentation modular aufgebaut und flexibel kombiniert werden können.

Lassen Sie und Schritt für Schritt starten:

=== Dokumentation als "plain text"

Nutzen Sie das das leichtgewichtige Markup-Format
Asciidoc footnote:[https://de.wikipedia.org/wiki/AsciiDoc] als Grundlage,
seit vielen Jahren bewährt. Im Gegensatz zum ebenfalls weit verbreiteten
https://daringfireball.net/projects/markdown/[Markdown] handelt sich bei AsciiDoc um einen wirklichen Standard,
ohne Fragmentierung durch unterschiedliche Dialekte
footnote:[Markdown wurde von John Gruber ursprünglich als minimalistisches Format definiert,
Erweiterungen für Tabellen, Modularisierung, Styling etc. haben unterschiedliche
Dialekte auf unterschiedliche Art realisiert. Texte in solchen Dialekten sind
in der Regel nicht 1:1 kompatibel mit anderen Dialekten.]
AsciiDoc ist sowohl einfach als auch funktional mächtig
footnote:[Der Ausdruck der detaillierten AsciiDoc Benutzerdokumentation würde 274 Druckseiten füllen.], und erfüllt
damit sämtliche oben genannten  Anforderungen an Dokumentation.
Bei Bedarf können Sie sogar Bücher damit schreiben.).

image:asciidoc-logo.svg[]

Für AsciiDoc gibt es einen (Open-Source, d.h. frei verfügbaren) Konverter
namens _Asciidoctor_ footnote:[https://asciidoctor.org/], der AsciiDoc in verschiedene
Zielformate (etwa Html oder DocBook) konvertieren kann.

In Abbildung <<dac-uebersicht>> finden Sie eine Übersicht:

1. Verschiedene Beteiligte, etwa das Entwicklungsteam oder die ArchitektInnen, erstellen
jeweils Teile der Dokumentation, sowohl in Textform als AsciiDoc-Dateien, als auch
Diagramme.
2. Ein Build-Prozess kombiniert und konvertiert diese einzelnen Teile zu den gewünschten Zielformaten,
beispielsweise HTML oder pdf. In Folge 2 dieses Artikels zeigen wir Ihnen, wie Sie sehr einfach
auch Confluence, docx oder andere Formate erzeugen können.
3. Andere Stakeholder arbeiten weiterhin in ihren etablierten Werkzeugen, etwa Word. Deren
Dokumentation liegt in Office-Formaten, etwa docx oder xlsx vor.
4. Die docToolchain (genauer erklärt in Folge 2) integriert auch solche Formate.

[[dac-uebersicht]]
.Docs-as-Code in der Übersicht
image::docs-as-code-uebersicht.png[]

Aber jetzt wird es Zeit für konkrete Details. Sie werden sehen, dass
schreiben mit AsciiDoc wirklich einfach geht:

****
Falls Sie unsere Beispiele direkt selbt nachvollziehen möchten, finden Sie den
Quellcode in unserem öffentlichen
https://github.com/doctoolchain/XXXX[Github-Repository].

****

=== Überschriften

Erzeugen Sie Überschriften einfach durch ein vorangestelltes `=`,
wobei die Überschrifteneben der Anzahl der `=`-Zeichen entspricht.
Ein einzelnes `=` ist dem Buchtitel oder Dokumentnamen vorbehalten,
so dass ein normaler Text mit `==` als erste Überschriftenebene beginnt.

.Überschriften
[options="noheader",cols="l,a"]
|===
|
== Überschrift Ebene 1
|
== Überschrift Ebene 1

|
=== Überschrift Ebene 2
|
=== Überschrift Ebene 2

|===

=== Absätze

AsciiDoc ignoriert einfache Zeilenumbrüche und erkennt erst nach einer Leerzeile
einen Absatz. Dieser Mechanismus hilft beim strukturieren von Texten.
Möchten Sie dennoch gezielt einen Zeilenumbruch setzen,
so beenden Sie die Zeile mit einem Leerzeichen und `+`

.Absätze
[options="noheader",cols="l,a"]
|===
|
Zeile 1
Zeile 2
Zeile 3
|
Zeile 1
Zeile 2
Zeile 3

|
neuer Absatz mit +
erzwungenem Umbruch
|
neuer Absatz mit +
erzwungenem Umbruch
|===

=== Textformate
Text können Sie einfach in den "üblichen" Formaten darstellen. Darüber hinaus
bietet AsciiDoc die Möglichkeit, beliebige css-Styles anzuwenden, aber das sprengt
den Rahmen dieser kompakten Einführung.

.Textformate
[options="noheader",cols="l,a"]
|===
| **fett**
| **fett**

| _kursiv_
| _kursiv_

| `monospaced`
| `monospaced`

| Etwas [small]#kleiner#
| Etwas [small]#kleiner#

| Oder [big]#größer#
| Oder [big]#größer#

|===


=== Listen
Sowohl Listen wie (nummerierte) Aufzählungen funktionieren mit AsciiDoc intuitiv

.Listen
[options="noheader",cols="l,a"]
|===
| Einfache Liste (Vor dem ersten Punkt muss eine Leerzeile stehen)

* Ein Punkt
* Noch ein Punkt
** Unterpunkt a
** Unterpunkt b

| Einfache Liste

* Ein Punkt
* Noch ein Punkt
** Unterpunkt a
** Unterpunkt b

| Nummerierte Liste

1. Punkt 1
2. Punkt 2
| Nummerierte Liste

1. Punkt 1
2. Punkt 2

|===

AsciiDoc bietet noch eine Vielzahl weiterer Möglichkeiten für solche Auflistungen
an, mehr Details finden Sie in der
https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#lists[Original-Dokumentation].

=== Links und Verweise

URLs können Sie einfach schreiben, sie werden von Asciidoctor als solche erkannt
und im Zielformat (beispielsweise HTML) entsprechend verlinkt.
Möchten Sie die URL im Text durch einen Text ersetzen,
so hängen Sie diesen in eckigen Klammern einfach dran, und fertig.

Relative Verweise zwischen mehreren Dokumenten wie z.B. `docs/tutorial.html` kann
Asciidoctor aufgrund der fehlenden Protokollbezeichnung nicht automatisch erkennen.
Setzen Sie einfach ein `link:` davor und leere Klammern `[]`dahinter und alles
ist wie gehabt.

[[tabelle-links]]
.Links
[options="noheader",cols="l,a"]
|===
| https://docs-as-co.de
| https://docs-as-co.de

| https://docs-as-co.de[Docs-as-Co.de]
| https://docs-as-co.de[Docs-as-Co.de]

| link:docs/tutorial.html[]
| link:docs/tutorial.html[]

| link:docs/tutorial.html[Tutorial]
| link:docs/tutorial.html[Tutorial]

|===

AsciiDoctor unterstützt auch Querverweise innerhalb des Dokuments.
Mit doppelten eckigen Klammern `\[[ein-anker]]` setzen Sie Anker im Dokument gesetzt, auf die Sie mit spitzen Klammern `\<<ein-anker>>` verweisen.

Wie Asciidoctor die Referenz benennt steuern Sie über das Attribut `:xrefstyle:`.

.Verweise
[options="noheader",cols="l,a"]
|===
|
:xrefstyle: short
Siehe <<tabelle-links>>
|
Siehe link:.[Tabelle 3]

|
:xrefstyle: full
Siehe <<tabelle-links>>
|
Siehe link:.[Tabelle 3, "Links"]

|
:xrefstyle: basic
Siehe <<tabelle-links>>
|
Siehe link:.[Links]

|===

Asciidoctor setzt übrigens viele Anker als Sprungziele für Überschriften,
Tabellen und Bilder automatisch.
Das vereinfacht Querverweise erheblich, weil Sie diese Sprungziele nicht mehr manuell
definieren müssen (aber Vorsicht - wenn Sie eine Überschrift umbenennen, so ändert
  sich damit auch der automatisch erzeugte Anker!).


=== Bilder und Diagramme

Bilder und Diagramme können Sie ähnlich wie Querverweise einfügen - stellen
Sie einfach das Wort "image" voran: `image:<name-des-bildes>[]`. In der folgenden
Tabelle zeigen wir Ihnen gleich noch die Möglichkeiten der Skalierung von Diagrammen.



.Bilder
[options="noheader",cols="l,a"]
|===
| Docs-as-Code image:hhgdac-logo.png[] macht Spass!
| Docs-as-Code image:hhgdac-logo.png[width=20%] macht Spass!

| Das selbe Bild image:hhgdac-logo.png[width=10%] in kleiner.
| Das selbe Bild image:hhgdac-logo.png[width=10%] in kleiner.

| Bilder in eigenen Zeilen

image::hhgdac-logo.png[]

klappen auch.
| Bilder in eigenen Zeilen

image::hhgdac-logo.png[]

klappen auch.

|===

Diagramme und Bilder stellen wichtige Elemente technischer Dokumentation dar,
weil sie Zusammenhänge aufzeigen und Überblick ermöglichen. Oftmals erstellen Sie
Diagramme in einem speziell dafür vorgesehenen Werkzeug
Sie sind aber immer nur die Darstellung der Daten einer Quelle.
Binden Sie nur die Bilder in Ihre Dokumentation ein, so geht automatisch der enge Bezug zur Quelle verloren.

Für UML-Diagramme schlagen wir Ihnen eine elegante Lösung namens PlantUML vor:
Damit beschreiben Sie Ihr Diagramm textuell und überlassen es Asciidoctor,
das Diagramm in ein Bild zu wandeln. Unter der Haube nutzt AsciiDoctor dafür
den Open Source Konverter, der die textuelle Syntax von PlantUML in Grafikformate
wie jpg oder png verwandelt.

[[plantuml]]
.PlantUML
[options="noheader",cols="l,a"]
|===

|
[plantuml, "sequence", png]
....
actor Benutzer
Benutzer -> Browser
    Browser -> Server
    Browser <-- Server
Benutzer <-- Browser
....

|
[plantuml, "sequence", png]
....
actor Benutzer
Benutzer -> Browser
    Browser -> Server
    Browser <-- Server
Benutzer <-- Browser
....
|===

=== Quellcode

In Ihrer technischen Dokumentation werden Sie an einigen Stellen
Quellcode oder zumindest Code-Fragmente einfügen und erklären wollen.

AsciiDoc bietet dafür sehr leistungsfähige Möglichkeiten. Beginnen wir
mit der reinen Darstellung von Quellcode: Syntax-Highlighing, Zeilennummern
und Markierungen, damit können Sie schon eine ganze Menge _anstellen_:

[options="noheader",cols="l,a"]
|===

|.Quellcode (einfach)
[source,go]
----
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
----
|.Quellcode (einfach)
[source,go]
----
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
----

|.Quellcode (mit Zeilennummern)
[source,go, linenums]
----
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
----
|.Quellcode (mit Zeilennummern)
[source,go, linenums]
----
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
----


|.Code mit Erklärungen
[source,java]
----
import org.harryp.Voldemort; // <1>
import org.harryp.Harry; // <2>

public class Stakeholder {

    public String wandName; // <3>

    // ...
}
----
<1> diesen Namen besser vermeiden
<2> der Knabe mit der Brille
<3> Zauberstäbe tragen Namen

|.Code mit Erklärungen
[source,java]
----
import org.harryp.Voldemort; // <1>
import org.harryp.Harry; // <2>

public class Stakeholder {

    public String wandName; // <3>

    // ...
}
----
<1> diesen Namen besser vermeiden
<2> der Knabe mit der Brille
<3> Zauberstäbe tragen Namen

|===


=== Textkästen (Sidebars)
Manchmal möchten Sie Inhalte besonders hervorheben

[options="noheader",cols="l,a"]
|===
|.Sidebar (Textkasten)
****
hier steht besonders hervorgehobener Text
****
|.Sidebar (Textkasten)
****
hier steht besonders hervorgehobener Text
****

|===


=== Tabellen

Tabellen leiten Sie mit `|===`. Sie können in eckigen Klammern Optionen
zur Darstellung der Tabelle angeben. Spalten trennen Sie mit `|`.

----
[cols=3,options="header"]
|===
|Header-1 | Header-2  <1>
|c1r1 |c2r1
|c1r2 |c2r2
|===
----
<1> Die erste Zeile verwendet AsciIDoc als Überschrift (_Header_)


[cols=3,options="header"]
|===
|Header-1 | Header-2 
|c1r1 |c2r1
| c1r2 | c2r2
|===

Jetzt möchten wir die Spaltenbreite der Tabelle beeinflussen. Eine Möglichkeit
ist es, die _relative_ Breite einer Spalte in der `cols=` Definition anzugeben.
Das funktioniert ebenfalls mit prozentualen Angaben.

[cols="1,2,4"]
|===
|Cell in column 1, row 1
|Cell in column 2, row 1
|Cell in column 3, row 1

|Cell in column 1, row 2
|Cell in column 2, row 2
|Cell in column 3, row 2
|===


Diese Tabelle wird mit dem folgenden AsciiDoc erzeugt:

[source,asciidoc]
----
[cols="1,2,4"]<1>
|===
|Cell in column 1, row 1
|Cell in column 2, row 1
|Cell in column 3, row 1

|Cell in column 1, row 2
|Cell in column 2, row 2
|Cell in column 3, row 2
|===
----
<1> zweite Spalte hat die doppelte Breite der ersten, die dritte Spalte die vierfache.

Der https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/#tables[AsciiDoctor Writers' Guide]
hält noch eine Reihe weiterer Möglichkeiten
bereit - Spalten- und Zeilenformatierung, links- und rechtsbündige Spalten
und so weiter.


=== Modulare Dokumentation

Im Normalfall möchten Sie gemeinsam mit Ihrem Team an Dokumentation arbeiten,
d.h. Sie müssen Dokumente modularisieren. In AsciiDoc geht das sehr elegant,
nämlich durch die `include`-Anweisung.

Sie können Dokumentation damit in kleine Teile zerlegen, im Team getrennt bearbeiten
und bei Bedarf an beliebigen Stellen wieder einfügen.

Schematisch sehen Sie das in Abbildung <<abb-modularisierung>>.

[[abb-modularisierung]]
.Modularisierung mit AsciiDoc - schematisch:
image::modularisierung-uebersicht.png[]

Falls Sie etwa die Architektur eines Systems mit Hilfe des https://arc42.org[arc42 Templates]
pragmatisch dokumentieren möchten, so können Sie die einzelnen Sektionen von arc42
in jeweils einzelnen Dateien speichern und flexibel aus einem Master-Dokument inkludieren,
ganz ohne Redundanz.

Für umfassende Dokumentation können Sie Teile der modularisierten Dokumentation sogar
problemlos an mehreren Stellen verwenden - wie Abbildung <<abb-wiederverwendung>> zeigt.

Wir nutzen das für so genannten Architecture Decision Records (ADRs),
mit deren Hilfe wir Implementierungs- oder Architekturentscheidungen zuerst im Team
diskutieren (und sie in der Entwicklungsdokumentation informell als eine
  AsciiDoc-Datei festhalten). Stellt
sich später heraus, dass sie besondere Relevanz in der Architektur besitzen, so können
wir diese Datei problemlos an passender Stelle in unserer Dokumentation inkludieren.




[[abb-wiederverwendung]]
.Teile von Dokumentation wiederverwenden
image::venom-doc-architecture.png[]


== Fazit



=== Überschriften
Textformatierungen, Aufzählungen (Listen)

* kennen Sie von Wikis oder Markdown:
* Formate wie *fett*, _kursiv_
* Auch Links sind einfach: http://javamagazin.de[JavaMagazin].

.Code-Highlighting
[source,groovy]
10.times { println "Hello, AsciiDoc!" }
