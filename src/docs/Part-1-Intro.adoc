:source-highlighter: coderay
:imagesdir: images
:figure-caption: Abbildung
:xrefstyle: short

== Docs-As-Code - Die Grundlagen

In einer grossangelegten Umfrage über Open Source wurde auf die Frage, welches die größten Probleme sind, wurde als Hauptproblem unvollständige oder verwirrende Dokumentation genanntfootnote:[https://opensourcesurvey.org/2017/].
Dies trifft natürlich nicht nur auf Open Source Projekte zu, sondern im allgemeinen ist undokumentierte Software nicht nur schwer zu verwenden, sondern auch teurer im Support und der Wartung.

Die Gründe für unzureichende Dokumentation sind vielfältig.
Ein Grund ist aber mit Sicherheit das Erstellen der Dokumentation an sich.
Und wenn die Dokumentation erstellt ist, muss sie mit der Software gewartet und aktualisiert werden.

Wir zeigen Ihnen, wie Sie das ungeliebten Thema _Dokumentation_ mit Hilfe robuster Open-Source Werkzeuge einfach und effektiv in die Softwareentwicklung integrieren.

Damit decken Sie sowohl Entwicklungs- und Architekturdokumentation ab,
aber auch User- und Betriebsdokumentation. Entwicklungsteams können Code-nah
mit Hilfe von Plaintext arbeiten, Dokumente modular aufteilen und ihre Doku in den Build-Prozess ihrer Software integrieren. Sollten Sie in Ihrem Team bereits mit https://arc42.org[arc42] arbeiten,
so werden Sie sich mit dem Docs-As-Code Ansatz besonders wohl fühlen.

Andere Beteiligte ("Stakeholder") dürfen ihre favorisierten Tools wie Word,
Powerpoint, Excel oder auch Enterprise-Architect(TM) weiter verwenden -

Falls das für Sie attraktiv klingt - dann lesen Sie weiter.
Diese breite Palette an _Features_ bringen wir Ihnen in drei kleinen Portionen näher:

1. Grundlagen: In der vorliegenden Folge zeigen wir Ihnen AsciiDoc als
unsere favorisierte Grundlage für technische Dokumentation. Sie erfahren allerhand
über Gliederung, Formatierung, Modularisierung, Integration von Diagrammen
und Quellcode.
2. In der zweiten Folge lernen Sie docToolchain kennen, die OpenSource Lösung zur Unterstützung des Docs-As-Code Ansatzes.
 Sie lernen die Integration von Office-Dokumenten, Confluence(tm) und Enterprise-Architect(TM)  in ihre Dokumentation kennen.
3. In der dritten Folge bringen wir _alles unter einem Dach_ unter:
Sie erfahren, wie Sie die verschiedenen Arten von Dokumentation (etwa Architektur- und Entwicklungsdokumentation sowie User-Manuals, Tutorials
 etc) im Rahmen einer integrativen Website zusammenführen können.

Sämtlichen Quellcode und Beispiele aller drei Teile finden Sie online in einem öffentlichen (git-) Repository.

Um Ihnen das manchmal ungeliebte Thema _Dokumentation_ etwas schmackhaft zu machen, möchten wir Ihnen einen Ausblick auf das mögliche Endergebnis geben: Eine Website
(siehe <<hsc-homepage>>), auf der Sie drei verschiedene Typen von Dokumentation unter einem (homogenen) Dach vereinigt finden:

== So sieht's aus
In <<hsc-homepage>> sehen Sie eine (generierte) Website, auf der wir die gesamte
Dokumentation für ein Softwaresystem zusammengeführt haben.

[[hsc-homepage]]
.Eine Doku-Website
image::hsc-aim42-site-screenshot.png[]

//TODO: insert live screenshot https://github.com/asciidoctor/asciidoctorj-screenshot
//note: läuft nicht. Macht wahrscheinlich auch als Test mehr Sinn
// screenshot::https://hsc.aim42.org[htmlSanityChecker, frame=BROWSER]


In der Navigationsleiste dieser Site finden Sie drei typische Arten von
Dokumentation, nämlich "User-Guide" (Benutzungsanleitung oä), "Development Guide"
(detaillierte Informationen für das Entwicklungsteam) sowie die Architekturdokumentation,
beispielsweise auf Basis des https://arc42.org[arc42 Templates].

Probieren Sie das Original unter https://hsc.aim42.org ruhig aus. Die gesamte
Site wird generiert, sämtliche Quellen liegen unter Versionsverwaltung und
sind im Github-Reository öffentlich.

== Was ist das Problem?
Den größten Teil technischer Dokumentation schreiben Entwicklungsteams,
und die mögen ihre Entwicklungsumgebungen viel lieber als die üblichen Office-Tools wie Word oder Excel.
Zur pflege klassischer Dokumentation muss ein Entwickler aus seiner IDE in den Kontext der Textverarbeitung wechseln.
Das kostet Überwindung.
Programmbeispiele werden aus der Quelle kopiert und sind somit schon veraltet.

Warum nicht die gleichen Tools für die Dokumentation verwenden, die auch für die Erstellung und Verwaltung von Sourcecode verwendet werden?

== Anforderungen an (technische) Dokumentation

Der wahrscheinlich größre Teil technischer Dokumentation besteht aus Fliesstext und Codebeispielen mit dem Ergebnis der Ausführung - Text und Screenshots.
Allerdings stellen unterschiedliche Dokumentationsarten auch unterschiedliche Anforderungen and wie zur Erstellung benötigten Werkzeuge.

Ein Blick auf das arc42-Template footnote:[https://arc42.org] zur Dokumentation der Architektur vons Softwaresystemen zeigt, dass bei Architekutrdokumentation auch tabellarische Übersichten und viele Diagramme benötigt werden.

== Dokumentation als "plain text"

Das Markup-Format Asciidoc footnote:[https://de.wikipedia.org/wiki/AsciiDoc] zusammen mit dem Konverter Asciidoctor footnote:[https://asciidoctor.org/] hat sich zur Erstellung technischer Dokumentation mit den genannten Anforderungen nicht nur bewährt, sondern auch klar von anderen Formaten wie MarkDown abgehoben:

* Es handelt sich um einen wirklichen Standard - keine Dialekte
* Es ist sehr mächtig und erfüllt smit alle Wünsche
* Es unterstützt Tabellen, Modularisierung verschiedene Ausgabeformate und vieles mehr.

== Diagramme und Bilder

== Tabellen

== Links und Verweise

== Modulare Dokumentation

Sie möchten im Team an Dokumentation arbeiten
Durch `include`-Anweisungen modularisieren wir die Dokumentation,
d.h. wir können sie in kleine Teile zerlegen, im Team getrennt bearbeiten
und bei Bedarf an beliebigen Stellen wieder einfügen.

Schematisch sehen Sie das in Abbildung XX.

----
include::hello.adoc[]
----

== Fazit



=== Überschriften
Textformatierungen, Aufzählungen (Listen)

* kennen Sie von Wikis oder Markdown:
* Formate wie *fett*, _kursiv_
* Auch Links sind einfach: http://javamagazin.de[JavaMagazin].

.Code-Highlighting
[source,groovy]
10.times { println "Hello, AsciiDoc!" }
