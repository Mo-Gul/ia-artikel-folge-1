:source-highlighter: coderay
:imagesdir: images
:figure-caption: Abbildung
:table-caption: Tabelle
:example-caption: Beispiel
:xrefstyle: short
:sectanchors:


== Docs-As-Code - Die Grundlagen

=== Schlechte Dokumentation  kostet Geld

Eine grossangelegte Umfragefootnote:[https://opensourcesurvey.org/2017/]
zu "Open Source" zeigt, dass unvollständige oder verwirrende Dokumentation
zu den Hauptproblem freier Software zählt. Das gilt neben Anwendungungsdokumentation
insbesondere auch für technische Dokumentation, etwa von Softwarearchitektur.

Diese Aussage können wir sicherlich
verallgemeinern -  schlechte Dokumentation von Software erschwert
Änderung, Support und letztlich auch Nutzung.

Wir möchten hier auf _technische Dokumentation_ von Software abzielen, also
beispielsweise Entwicklungs-, Architektur- und Betriebsdokumentation. Das Thema
_Anwendungsdokumentation_ klammern wir bewusst aus.

Unserer Erfahrung nach behindern eine ganze Reihe von Faktoren
die Erstellung und kontinuierliche Pflege technischer Dokumentation:

1. Ungeeignete Werkzeuge, die ursprünglich nicht für Erstellung und Pflege
solcher Dokumentation gedacht waren.
2. Geringe Motivation seitens Entwicklungsteams, oftmals verstärkt durch die
oben genannten Defizite der entsprechenden Werkzeuge.
3. Unklare Vorstellung über Struktur, Form und Inhalt von Dokumentation:
Entwicklungsteams haben keine klare Vorstellung davon, was und wie sie
dokumentieren sollen.
4. Schlechte Vorlagen ("Templates") für Dokumentation.

=== Technische Dokumentation als "Leichtgewicht"
Stellen Sie sich vor, Sie erstellen und pflegen Ihre technische Dokumentation
genau so wie auch Ihren Quellcode: Im selben Texteditor oder einer IDE,
als reiner Text, versioniert in Ihrem Lieblings-Repository (wir mögen Git).
Dann verschwindet für Entwicklungsteams das erste der oben genannten Probleme (nämlich
  die ungeeigneten Werkzeuge), und die Motivation zur Erstellung und Pflege von Doku
  wird auch gleich besser.

Wir zeigen Ihnen genau diesen Ansatz: Integrieren Sie das bisher ungeliebten
Thema _Dokumentation_ mit Hilfe robuster Open-Source Werkzeuge einfach und effektiv
in Ihre Softwareentwicklung, mit Hilfe Ihres favorisierten Texteditors.
_Mergen_ und _branchen_ Sie Dokumentation genau wie Quellcode. Statt binäre Dokumente
per Email zu versenden und Versionsnummern und Namenskürzel an die Dateinamen zu hängen,
checken Sie Ihre Dokumentation per commit und push ein, mit derselben Branching-Strategie
mit der Sie auch Ihre Software entwickeln.

Damit können Sie ein breites Spektrum technischer Dokumentation von Software abdecken,
beispielsweise Entwicklungs-, Architektur- oder auch Betriebsdokumentation.  Wir persönlich
haben auch User- auf diese Weise erstellt.

Für diesen Ansatz hat sich im Netz der Begriff _Docs-as-Code_ etabliert -
Dokumentation genauso wie Quellcode behandeln.

Mit Docs-as-Code reduzieren Sie bisherige Hemmschwellen, die durch Werkzeugwechsel
und/oder Medienbrüche aufgetreten sind. Sie können Dokumente beliebig aufteilen
(sprich: im Team arbeitsteilig angehen), und Dokumentation
in den Build- und Testprozess ihrer Software integrieren.

Sollten Sie in Ihrem Team bereits mit https://arc42.org[arc42] arbeiten,
so werden Sie sich mit dem Docs-As-Code Ansatz besonders wohl fühlen.

Andere Beteiligte (_Stakeholder_) dürfen ihre favorisierten Tools wie Word,
Powerpoint, Excel oder auch Enterprise-Architect(TM) weiter verwenden,
denn Docs-as-Code kann automatisiert eine Vielzahl anderer Dokumenttypen integrieren
(darauf gehen wir im zweiten Teil dieses Artikels detalliert ein).

Falls das für Sie attraktiv klingt - herzlich willkommen. Wir haben diese Ansätze
bereits mehrfach in der Praxis erfolgreich einsetzen dürfen - und einige unserer
Erfahrungen in diesem und den folgenden Artikeln verarbeitet.

Erwarten Sie _Docs-as-Code_ in den folgenden drei Portionen:

1. Grundlagen: In der vorliegenden Folge zeigen wir Ihnen AsciiDoc als
unsere favorisierte Grundlage für technische Dokumentation. Sie erfahren allerhand
über Gliederung, Formatierung, Modularisierung, Integration von Diagrammen
und Quellcode.
2. In der zweiten Folge lernen Sie docToolchain kennen, die OpenSource Lösung zur Unterstützung des Docs-As-Code Ansatzes.
 Sie lernen die Integration von Office-Dokumenten, Confluence(tm) und Enterprise-Architect(TM)  in ihre Dokumentation kennen.
3. In der dritten Folge bringen wir _alles unter einem Dach_ unter:
Sie erfahren, wie Sie die verschiedenen Arten von Dokumentation (etwa Architektur- und Entwicklungsdokumentation sowie User-Manuals, Tutorials
 etc) im Rahmen einer integrativen Website zusammenführen können.

Sämtlichen Quellcode und Beispiele aller drei Teile finden Sie online in einem öffentlichen (git-) Repository.

Um Ihnen das manchmal ungeliebte Thema _Dokumentation_ etwas schmackhaft zu machen, möchten wir Ihnen einen Ausblick auf das mögliche Endergebnis geben: Eine Website
(siehe <<hsc-homepage>>), auf der Sie drei verschiedene Typen von Dokumentation unter einem (homogenen) Dach vereinigt finden:

== So sieht's aus
In <<hsc-homepage>> sehen Sie eine (generierte) Website, auf der wir die gesamte
Dokumentation für ein Softwaresystem zusammengeführt haben.

[[hsc-homepage]]
.Eine Doku-Website
image::hsc-aim42-site-screenshot.png[]

//TODO: insert live screenshot https://github.com/asciidoctor/asciidoctorj-screenshot
//note: läuft nicht. Macht wahrscheinlich auch als Test mehr Sinn
// screenshot::https://hsc.aim42.org[htmlSanityChecker, frame=BROWSER]


In der Navigationsleiste dieser Site finden Sie drei typische Arten von
Dokumentation, nämlich "User-Guide" (Benutzungsanleitung o.ä.), "Development Guide"
(detaillierte Informationen für das Entwicklungsteam) sowie die Architekturdokumentation,
beispielsweise auf Basis des https://arc42.org[arc42 Templates].

Probieren Sie das Original unter https://hsc.aim42.org ruhig aus. Die gesamte
Site wird generiert, sämtliche Quellen liegen unter Versionsverwaltung und
sind im Github-Reository öffentlich.


== Anforderungen an (technische) Dokumentation

Der wahrscheinlich größre Teil technischer Dokumentation besteht aus Fliesstext und Codebeispielen mit dem Ergebnis der Ausführung - Text und Screenshots.
Allerdings stellen unterschiedliche Dokumentationsarten auch unterschiedliche Anforderungen and wie zur Erstellung benötigten Werkzeuge.

Ein Blick auf das arc42-Template footnote:[https://arc42.org] zur Dokumentation der Architektur vons Softwaresystemen zeigt, dass bei Architekutrdokumentation auch tabellarische Übersichten und viele Diagramme benötigt werden.

== Dokumentation als "plain text"

Das Markup-Format Asciidoc footnote:[https://de.wikipedia.org/wiki/AsciiDoc] zusammen mit dem Konverter Asciidoctor footnote:[https://asciidoctor.org/] hat sich zur Erstellung technischer Dokumentation mit den genannten Anforderungen nicht nur bewährt, sondern auch klar von anderen Formaten wie MarkDown abgehoben:

* Es handelt sich um einen wirklichen Standard - keine Dialekte
* Es ist sehr mächtig und erfüllt smit alle Wünsche
* Es unterstützt Tabellen, Modularisierung verschiedene Ausgabeformate und vieles mehr.

AsciiDoc ist so mächtig, dass ein Ausdruck der Benutzerdokumentation 274 Seiten füllen würde.
Wir zeigen Ihnen hier die wichtigsten Features, damit Sie schnell loslegen können.

=== Überschriften

Überschriften werden einfach mit vorangestellten `=` definiert, wobei die Überschrifteneben der Anzahl der `=`-Zeichen entspricht.
Ein einzelnes `=` ist dem Buchtitel vorbehalten, so dass ein normaler Text mit `==` als erste Überschriftenebene beginnt.

.Überschriften
[options="noheader",cols="l,a"]
|====
|
== Überschrift Ebene 1
|
== Überschrift Ebene 1

|
=== Überschrift Ebene 2
|
=== Überschrift Ebene 2

|====

=== Absätze

AsciiDoc ignoriert einfache Zeilenumbrüche und erkennt erst nach einer Leerzeile einen Absatz.
Dieser Mechanismus hilft beim strukturieren von Texten.
Möchten Sie dennoch gezielt einen Zeilenumbruch setzen, so beenden Sie die Zeile mit einem Leerzeichen und `+`

.Absätze
[options="noheader",cols="l,a"]
|====
|
Zeile 1
Zeile 2
Zeile 3
|
Zeile 1
Zeile 2
Zeile 3

|
neuer Absatz mit +
erzwungenem Umbruch
|
neuer Absatz mit +
erzwungenem Umbruch
|====

=== Links und Verweise

Eine URL wird von Asciidoctor als solche erkannt und entsprechend verlinkt.
Möchten Sie die URL im Text durch einen Text ersetzen, so hängen Sie diesen in eckigen Klammern einfach dran. fertig.

Realtive Verweise zwischen mehreren Dokumenten wie z.B. `docs/tutorial.html` kann Asciidoctor aufgrund des fehlenden Protokolls nicht automatisch erkennen.
Setzen Sie einfach ein `link:` davor und leere Klammern `[]`dahinter und alles ist wie gehabt.

[[tabelle-links]]
.Links
[options="noheader",cols="l,a"]
|===
| https://docs-as-co.de
| https://docs-as-co.de

| https://docs-as-co.de[Docs-as-Co.de]
| https://docs-as-co.de[Docs-as-Co.de]

| link:docs/tutorial.html[]
| link:docs/tutorial.html[]

| link:docs/tutorial.html[Tutorial]
| link:docs/tutorial.html[Tutorial]

|===

AsciiDoctor unterstützt auch Querverweise innerhalb des Dokuments.
Mit doppelten eckigen Klammern `\[[ein-anker]]` setzen Sie Anker im Dokument gesetzt, auf die Sie mit spitzen Klammern `\<<ein-anker>>` verweisen.

Wie Asciidoctor die Referenz benennt steuern Sie über das Attribut `:xrefstyle:`.

.Verweise
[options="noheader",cols="l,a"]
|===
|
:xrefstyle: short
<<tabelle-links>>
|
link:.[Tabelle 3]

|
:xrefstyle: full
<<tabelle-links>>
|
link:.[Tabelle 3, "Links"]

|
:xrefstyle: basic
<<tabelle-links>>
|
link:.[Links]

|===

Asciidoctor setzt übrigens viele Anker als Sprungziele für Überschriften, Tabellen und Bilder automatisch.
Das vereinfacht die Arbeit noch weiter.

=== Bilder und Diagramme

Apropos Bilder. Für Links haben Sie schon die Makro-Syntax von Asciidoc kennen gelehrnt. `\link:seite.html[text]` oder allgemeiner `makro:ziel[optionen]`.
Diese Syntax begenet Ihnen imemr wieder, so daß es sich lohnt sie zu verinnerlichen.
So auch z.B. beim referenzieren von Bildern:

.Bilder
[options="noheader",cols="l,a"]
|===
| image:hhgdac-logo.png[]
| image:hhgdac-logo.png[]

|===

Der Doppelpunkt `:` zwischen dem Makro-Namen und dem Ziel bestimmt übrigens, ob es sich um ein Inline- `:` oder Block- `::` Makro handelt.
So können Sie steurn, ob das Bild innerhalb eines Textes (inline) oder alleinstehend als Absatz (block) dargestellt wird.

.Bilder
[options="noheader",cols="l,a"]
|===
| Docs-as-Code image:hhgdac-logo.png[] macht Spass!
| Docs-as-Code image:hhgdac-logo.png[width=20%] macht Spass!

| Docs-as-Code

image::hhgdac-logo.png[]

macht Spass!
| Docs-as-Code

image::hhgdac-logo.png[width=20%]

macht Spass!

|===

Bilder sind mächtig, denn Sie können viel mit ihnen darstellen.
Sie sind aber immer nur die Darstellung der Daten einer Quelle.
Binden Sie nur die Bilder in Ihre Dokumentation ein, so geht automatisch der enge Bezug zur Quelle verloren.

Für UML-Diagramme gibt es da eine trickreiche Lösung.
Beschreiben Sie Ihr Diagramm doch einfach textuell und überlassen es Asciidoctor das Diagramm in ein Bild zu wandeln.
Das Tool, welches Asciidoctor hierfür verwendet heisst PlantUML.

[[plantuml]]
.PlantUML
[options="noheader",cols="l,a"]
|===

|
[plantuml, "sequence", png]
....
actor Benutzer
Benutzer -> Browser
    Browser -> Server
    Browser <-- Server
Benutzer <-- Browser
....

|
[plantuml, "sequence", png]
....
actor Benutzer
Benutzer -> Browser
    Browser -> Server
    Browser <-- Server
Benutzer <-- Browser
....
|===

=== Blöcke

Das Beispiel in <<plantuml>> zeigt nicht nur die Beschreibung eines Diagramms als versionierbaren Text sondern auch die Block-Syntax von AsciiDoc.

Blöcke vreschiedener Arten (z.B. Sidebar oder Zitat) werden mit mindestens vier gleichen Zeichen wie z.B. `.`, `-` oder `=` eingeleitet und mit genauso vielen Zeichen des gleichen Typs wieder beendet.
Stellen Sie dem Block (oder einem referenzierten Bild) eine Zeile voran, die Sie mit einem Punkt `.` einleiten und Sie erhalten eine Beschriftung.

.Passthrough
++++
Passthrough -
++++

.Literal
....
test <b>dfg</b>
....

.Sidebar
****
test <b>dfg</b>
****

.After landing the cloaked Klingon bird of prey in Golden Gate park:
[quote, Captain James T. Kirk, Star Trek IV: The Voyage Home]
____
Everybody remember where we parked.
____

.test
====
test <b>dfg</b>
====

.Listing
----
test <b>dfg</b>
----

=== Tabellen

Keine Regel ohne Ausnahme:
Tabellen sind Blöcke, die mit `|===` eingeleitet werden.


=== Modulare Dokumentation

Sie möchten im Team an Dokumentation arbeiten
Durch `include`-Anweisungen modularisieren wir die Dokumentation,
d.h. wir können sie in kleine Teile zerlegen, im Team getrennt bearbeiten
und bei Bedarf an beliebigen Stellen wieder einfügen.

Schematisch sehen Sie das in Abbildung XX.

----
include::hello.adoc[]
----

== Fazit



=== Überschriften
Textformatierungen, Aufzählungen (Listen)

* kennen Sie von Wikis oder Markdown:
* Formate wie *fett*, _kursiv_
* Auch Links sind einfach: http://javamagazin.de[JavaMagazin].

.Code-Highlighting
[source,groovy]
10.times { println "Hello, AsciiDoc!" }
